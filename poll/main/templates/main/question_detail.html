{% extends "base.html" %}

{% block title %}Question Detail{% endblock %}

{% block content %}
<h1 class="mb-4">Question Detail</h1>
<div class="mb-3">
  <strong>Question text:</strong>
  <pre>{{ question.text }}</pre>
</div>
<div class="mb-3">
  <strong>Number of question variations:</strong> {{ num_variations }}
</div>
<div class="mb-3">
  <strong>Total LLM queries:</strong> {{ total_queries }}
</div>

<h2 class="mt-5">Batches</h2>
<table class="table table-bordered">
  <thead>
    <tr>
      <th>Batch ID</th>
      <th>Status</th>
      <th>Created</th>
      <th>Updated</th>
    </tr>
  </thead>
  <tbody>
    {% for batch in batches %}
    <tr>
      <td>{{ batch.batch_id }}</td>
      <td>{{ batch.status }}</td>
      <td>{{ batch.created_at }}</td>
      <td>{{ batch.updated_at }}</td>
    </tr>
    {% empty %}
    <tr>
      <td colspan="4" class="text-center">No batches.</td>
    </tr>
    {% endfor %}
  </tbody>
</table>

<h2 class="mt-5">Answers</h2>
{% if has_answers %}
<p>
  <a class="btn btn-primary" href="{% url 'polls:question_answers_csv' question.uuid %}">Download CSV</a>
</p>

<h2 class="mt-5">Big-picture preference counts</h2>
<div class="row mb-3">
  {% for key, values in question.context.items %}
  <div class="col-auto">
    <label for="filter_{{ key }}" class="form-label">{{ key|title }}</label>
    <select id="filter_{{ key }}" data-key="{{ key }}" class="form-select context-filter">
      <option value="">All</option>
      {% for val in values %}
      <option value="{{ val }}">{{ val }}</option>
      {% endfor %}
    </select>
  </div>
  {% endfor %}
</div>
<canvas id="preferenceChart" height="120"></canvas>
<h3 class="mt-4">Head-to-head heatmap</h3>
<canvas id="heatmapChart" height="300"></canvas>
<h3 class="mt-4">Preference flows</h3>
<canvas id="sankeyChart" height="250"></canvas>
<h3 class="mt-4">Ranked league table</h3>
<canvas id="eloChart" height="150"></canvas>
<h3 class="mt-4">Answer confidence distribution</h3>
<canvas id="confidenceChart" height="120"></canvas>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@1.3.0/dist/chartjs-chart-matrix.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-chart-sankey@0.9.0/dist/chartjs-chart-sankey.min.js" crossorigin="anonymous"></script>
<script>
  const questionUuid = "{{ question.uuid }}";
  const ctx = document.getElementById('preferenceChart').getContext('2d');
  const heatCtx = document.getElementById('heatmapChart').getContext('2d');
  const sankeyCtx = document.getElementById('sankeyChart').getContext('2d');
  const eloCtx = document.getElementById('eloChart').getContext('2d');
  const confCtx = document.getElementById('confidenceChart').getContext('2d');
  const filters = document.querySelectorAll('.context-filter');
  let chart;
  let heatmap;
  let sankey;
  let eloChart;
  let confChart;

  async function loadChart() {
    const params = new URLSearchParams();
    filters.forEach(sel => { if (sel.value) params.append(sel.dataset.key, sel.value); });
    const resp = await fetch(`/api/charts/questions/${questionUuid}/preference-counts?` + params.toString());
    const data = await resp.json();
    const counts = data.counts || {};
    const labels = Object.keys(counts);
    const dataset = Object.values(counts);
    if (chart) {
      chart.data.labels = labels;
      chart.data.datasets[0].data = dataset;
      chart.update();
    } else {
      chart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Preference count',
            data: dataset,
            backgroundColor: 'rgba(54, 162, 235, 0.5)',
            borderColor: 'rgba(54, 162, 235, 1)',
            borderWidth: 1
          }]
        },
        options: {
          scales: { y: { beginAtZero: true, ticks: { precision: 0 } } }
        }
      });
    }
  }

  async function loadHeatmap() {
    const params = new URLSearchParams();
    filters.forEach(sel => { if (sel.value) params.append(sel.dataset.key, sel.value); });
    const resp = await fetch(`/api/charts/questions/${questionUuid}/preference-heatmap?` + params.toString());
    const data = await resp.json();
    const labels = data.choices || [];
    const matrix = data.matrix || [];
    const dataset = [];
    let max = 0;
    for (let y = 0; y < matrix.length; y++) {
      for (let x = 0; x < matrix.length; x++) {
        const v = matrix[y][x];
        if (v === null) continue;
        dataset.push({x, y, v});
        if (v > max) max = v;
      }
    }

    const color = v => `rgba(75, 192, 192, ${max ? v / max : 0})`;

    if (heatmap) {
      heatmap.data.datasets[0].data = dataset;
      heatmap.options.scales.x.labels = labels;
      heatmap.options.scales.y.labels = labels;
      heatmap.update();
    } else {
      heatmap = new Chart(heatCtx, {
        type: 'matrix',
        data: {
          datasets: [{
            label: 'Win count',
            data: dataset,
            backgroundColor(ctx) {
              const v = ctx.dataset.data[ctx.dataIndex].v;
              return color(v);
            },
            width: (ctx) => {
              const area = ctx.chart.chartArea;
              return area ? (area.width / labels.length) - 1 : 0;
            },
            height: (ctx) => {
              const area = ctx.chart.chartArea;
              return area ? (area.height / labels.length) - 1 : 0;
            },
          }]
        },
        options: {
          scales: {
            x: {type: 'category', labels: labels, position: 'top'},
            y: {type: 'category', labels: labels, reverse: true}
          },
        }
      });
    }
  }

  async function loadSankey() {
    const params = new URLSearchParams();
    filters.forEach(sel => { if (sel.value) params.append(sel.dataset.key, sel.value); });
    const resp = await fetch(`/api/charts/questions/${questionUuid}/preference-flows?` + params.toString());
    const data = await resp.json();
    const labels = data.labels || [];
    const links = data.links || [];
    if (sankey) {
      sankey.data.labels = labels;
      sankey.data.datasets[0].data = links;
      sankey.update();
    } else {
      sankey = new Chart(sankeyCtx, {
        type: 'sankey',
        data: {
          labels: labels,
          datasets: [{
            label: 'Preference flows',
            data: links
          }]
        },
        options: {responsive: true}
      });
    }
  }

  async function loadElo() {
    const params = new URLSearchParams();
    filters.forEach(sel => { if (sel.value) params.append(sel.dataset.key, sel.value); });
    const resp = await fetch(`/api/charts/questions/${questionUuid}/elo-ratings?` + params.toString());
    const data = await resp.json();
    const rows = data.rankings || [];
    const labels = rows.map(r => r.choice);
    const ratings = rows.map(r => r.rating);
    if (eloChart) {
      eloChart.data.labels = labels;
      eloChart.data.datasets[0].data = ratings;
      eloChart.update();
    } else {
      eloChart = new Chart(eloCtx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Elo rating',
            data: ratings,
            backgroundColor: 'rgba(255, 99, 132, 0.5)',
            borderColor: 'rgba(255, 99, 132, 1)',
            borderWidth: 1
          }]
        },
        options: {
          scales: { y: { beginAtZero: true } }
        }
      });
    }
  }

  async function loadConfidence() {
    const params = new URLSearchParams();
    filters.forEach(sel => { if (sel.value) params.append(sel.dataset.key, sel.value); });
    const resp = await fetch(`/api/charts/questions/${questionUuid}/confidence-distribution?` + params.toString());
    const data = await resp.json();
    const labels = data.labels || [];
    const counts = data.counts || [];
    if (confChart) {
      confChart.data.labels = labels;
      confChart.data.datasets[0].data = counts;
      confChart.update();
    } else {
      confChart = new Chart(confCtx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Answer count',
            data: counts,
            backgroundColor: 'rgba(153, 102, 255, 0.5)',
            borderColor: 'rgba(153, 102, 255, 1)',
            borderWidth: 1
          }]
        },
        options: { scales: { y: { beginAtZero: true, ticks: { precision: 0 } } } }
      });
    }
  }

  function reloadAll() { loadChart(); loadHeatmap(); loadSankey(); loadElo(); loadConfidence(); }
  filters.forEach(sel => sel.addEventListener('change', reloadAll));
  reloadAll();
</script>
{% else %}
<p>No answers.</p>
{% endif %}
{% endblock %}
